;; Unit tests for quickcheck

(unless (find-package "quickcheck") (load "quickcheck"))
(use-package "quickcheck")

(pprinl "CHECKPOINT 1")
(test (numargs 'rangep) (qsym 1 0 nil))
(test (numargs rangep) (sym 1 0 nil))
(test (numargs print) (sym 1 2 nil))
(test (numargs get-string) (sym 0 3 nil))
(test (numargs wrap) (sym 3 0 nil))
(test (numargs read) (sym 0 5 nil))
(test (numargs unique) (sym 1 1 t))
(test (numargs >) (sym 1 0 t))
(test (numargs (lambda (a b c) b)) (anon 3 0 nil))
(test (numargs #/foo/) (regex 1 2 nil))
(pprinl "CHECKPOINT 2")
(test (numargs (op +)) (list 0 0 t))
(test (numargs (op >)) (list 1 0 t))
(test (numargs (op car)) (list 1 0 nil))
(test (numargs (op (lambda (a b c) a))) (list 3 0 nil))
(test (numargs (op + @3)) (list 3 0 t))
(test (numargs (op + (- @1 @5) @2)) (list 5 0 t))
(test (numargs (op + 3)) (list 0 0 t))
(test (numargs (lop + @3)) (list 3 0 t))
(test (numargs (lop + (- @1 @5) @2)) (list 5 0 t))
(test (numargs (lop + 3)) (list 0 0 t))
(pprinl "CHECKPOINT 3")
(test (numargs (do + @3)) (list 3 0 t))
(test (numargs (do +)) (list 1 0 t))
(test (numargs (do >)) (list 1 0 t))
(test (numargs (do + (- @1 @5) @2)) (list 5 0 t))
(test (numargs (ldo + @3)) (list 3 0 t))
(test (numargs (ldo +)) (list 1 0 t))
(test (numargs (ldo >)) (list 1 0 t))
(test (numargs (ldo + (- @1 @5) @2)) (list 5 0 t))
(test (numargs (ado + @3)) (list 1 2 t))
(test (numargs (ado + (- @1 @5) @2)) (list 1 4 t))
(pprinl "CHECKPOINT 4")
(test (numargs (ido + @3)) (list 1 2 t))
(test (numargs (ido + (- @1 @5) @2)) (list 1 4 t))
(test (numargs (ap + @3)) (list 1 2 t))
(test (numargs (ap + (- @1 @5) @2)) (list 1 4 t))
(test (numargs (ip + @3)) (list 1 2 t))
(test (numargs (ip + (- @1 @5) @2)) (list 1 4 t))
(test (numargs (apf rangep)) (list 1 0 nil))
(test (numargs (ipf rangep)) (list 1 0 nil))
(test (numargs (apf print)) (list 1 2 nil))
(test (numargs (ipf print)) (list 1 2 nil))
(pprinl "CHECKPOINT 5")
(test (numargs (opip car numberp)) (list 1 0 nil))
(test (numargs (opip > numberp)) (list 1 0 t))
(test (numargs (orf 'integerp 'identity)) (list 1 0 nil))
(test (numargs (andf 'less 'identity)) (list 1 0 nil))
(test (numargs (andf 'print 'print)) (list 1 2 nil))
(test (numargs (andf (lambda (a : b c) a) 'identity)) (list 1 0 nil))
(test (numargs (andf (lambda (a b c) a) 'less)) (list 3 0 nil))
(test (numargs (andf (lambda (a b c) a) 'identity)) (list 3 -2 nil))
(test (numargs (andf (op less) 'identity)) (list 1 0 nil))
(test (numargs (andf (op (lambda (a b c) a)) 'identity)) (list 3 -2 nil))
(pprinl "CHECKPOINT 6")
(test (numargs (ret @1)) (list 1 0 t))
(test (numargs (ret @5)) (list 5 0 t))
(test (numargs (ret (+ @3 @5))) (list 5 0 t))
(test (numargs (ret (- @3 @rest))) (list 3 0 t))
(test (numargs (ret (- (+ @3 @4) @rest))) (list 4 0 t))
(test (numargs f^$) (sym 1 1 nil))
(test (numargs 'f^$) (qsym 1 1 nil))
(test (numargs (callf 'max 'identity 'succ)) (list 1 0 nil))
(test (numargs (callf 'max 'max 'succ)) (list 1 0 nil))
(test (numargs (callf 'max 'max 'max)) (list 1 0 t))
(pprinl "CHECKPOINT 7")
(test (numargs (callf 'max 'print 'max)) (list 1 0 nil))
(test (numargs (callf 'max 'print 'print)) (list 1 2 nil))
(test (numargs (callf 'max 'unique 'max)) (list 1 0 t))
(test (numargs (mapf 'max 'identity 'succ 'succ)) (list 1 2 t))
(test (numargs (mapf 'max 'succ 'identity 'succ 'succ)) (list 1 3 t))
(test (numargs (flipargs '<)) (list 2 0 nil))
(test (numargs (flipargs '>)) (list 2 0 nil))
(pprinl "CHECKPOINT 8")
(let ((fn (lambda (a b c) a)))
  (test (numargs fn) (var 3 0 nil)))
(let ((fn (op rangep)))
  (test (numargs fn) (var 1 0 nil)))
(let ((fn (andf 'rangep 'rangep)))
  (test (numargs fn) (var 0 0 t))) ;;should be (var 1 0 t), but there's no way numargs can know this
(let ((fn1 (andf 'rangep 'rangep)))
  (symacrolet ((fn2 fn1)) (test (numargs fn2) (symacro 0 0 t)))) ;; ERROR!
(pprinl "CHECKPOINT 9")
(flet ((fn (a b c) a))
  (test (numargs fn) (lfun 3 0 nil)))
(flet ((fn (a : b c) a))
  (test (numargs fn) (lfun 1 2 nil)))
(flet ((fn (a : b c . d) a))
  (test (numargs fn) (lfun 1 2 t)))
(pprinl "CHECKPOINT 10")
(macrolet ((mc (a b c) a))
  (test (numargs mc) (macro 3 0 nil)))
(macrolet ((mc (a : b c) a))
  (test (numargs mc) (macro 1 2 nil)))
(macrolet ((mc (a : b c . d) a))
  (test (numargs mc) (macro 1 2 t)))
(pprinl "CHECKPOINT 11")
(symacrolet ((sm (lambda (a b : c) a))) (test (numargs sm) (symacro 2 1 nil)))
(symacrolet ((sm (op rangep))) (test (numargs sm) (symacro 1 0 nil)))
(symacrolet ((sm (andf 'rangep 'rangep))) (test (numargs sm) (symacro 1 0 nil)))
(symacrolet ((sm rangep)) (test (numargs sm) (symacro 1 0 nil))) ;;ERROR!
(pprinl "CHECKPOINT 12")
(pprinl "Test 1")
(flet ((fn (a b : c d e . f) a))
  (symacrolet ((fn2 fn))
	      (test (numargs fn2) (symacro 2 3 t))))
(pprinl "Test 2")
(let ((fn1 (op wrap)))
  (symacrolet ((fn2 fn1))
	      (test (numargs fn2) (symacro 3 0 nil))))
(pprinl "Test 3")
(let ((fn1 #/foo/))
  (symacrolet ((fn2 fn1))
	      (test (numargs fn2) (symacro 1 2 nil))))
(pprinl "Test 4")
(let ((fn1 #/foo/))
  (symacrolet ((fn2 fn1))
	      (test (numargs fn2) (symacro 1 1 nil))))
(pprinl "Test 5")
(let ((fn1 #(1 2 3)))
  (symacrolet ((fn2 fn1))
	      (test (numargs fn2) (symacro 1 1 nil))))
(pprinl "Test 6")
(let ((fn1 '(1 2 3)))
  (symacrolet ((fn2 fn1))
	      (test (numargs fn2) (symacro 1 1 nil))))


