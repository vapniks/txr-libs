#!/usr/local/bin/txr
;; Run tests on txr packages
;; In txr evaluate: (load "unit_tests.tl"),
;; or on the command line: txr unit_tests.tl

(load "quickcheck.tl")
(use-package "quickcheck")

(let ((loadedpkgs (remq nil (mapcar (iff (chain 'cdr 'symbol-function) 'car 'nilf)
				    '(("ranges" . rrev) ("csv" . read-csv-stream)))))
      (loadpkg (juxt 'load 'use-package (op format t "Running tests for ~a package\n" @1))))
  [loadpkg "ranges"]
  ;; naming convention for qc-type objects: All names or qc-type objects begin with R (for random)
  ;;                                        int = object produces single integer
  ;;                                        rng = object produces single range
  ;;                                        l<N>int/l<N>rng = object produces list of at most <N> integers/ranges
  ;;                                        I = allow inf/:, S = allow stepsize,
  ;;                                        S* = always use stepsize, C = char ranges
  ;;                                        + = positive numbers only (inc 0),
  ;;                                        - = negative numbers only (inc 0)
  ;;                                        ~0 = disallow zero,
  ;;                                        5 = absolute value <= 5, 10 = absolute value <= 10
  (let* ((a2z #\a..#\z) (ints10 -10..10)
	 (Rbool (new (qc-bool)))
	 (Rint5 (new (qc-int -5..5)))
	 (Rint5+ (new (qc-int 0..5)))
	 (Rint5~0+ (new (qc-int 1..5)))
	 (Rint5- (new (qc-int 0..-5)))
	 (Rint5~0- (new (qc-int -1..-5)))
	 (RrngIS (new (qc-range ints10 ints10 nil nil (rlist -3..-1 1..3) t)))
	 (RrngIS* (new (qc-range ints10 ints10 nil nil (rlist -3..-2 2..3) t)))
	 (RrngSC (new (qc-range a2z a2z nil nil 1..3 nil)))
	 (RrngS (new (qc-range ints10 ints10 nil nil 1..3 nil)))
	 (Rl5rng10 (new (qc-list (list (new (qc-range ints10 ints10 nil nil nil nil))) 1..5)))
	 (Rl5rng10IS (new (qc-list (list (new (qc-range ints10 ints10 nil nil 1..3 t))) 1..5)))
	 (Rl5rngSC (new (qc-list (list (new (qc-range a2z a2z nil nil 1..3 nil))) 1..5)))
	 )
    (test (rfrom :..5) 0)
    (test (rfrom :..5..2) 0)
    (test (rto 0..:) :)
    (test (rto 0..:..2) :)
    (test (rstep 0..5) nil)
    (test (rstep 0..5..:) 1)
    (test (rstep 0..-5..:) -1)
    (test (rstep* 0..5) 1)
    (test (rstep* 5..0) -1)
    (test (rstep* 5..5) 0)
    (test (rset 0..5..2 1 6 3) #R(1 #R(6 3)))
    (test (rset 0..5..2 nil 'inf) #R(0 #R(: 2)))
    (quickcheck 50 (rfrom RrngIS) integerp)
    (quickcheck 50 (rfrom RrngSC) chrp)
    (quickcheck 50 (rfrom RrngS) (eq results (from (car args))))
    (quickcheck 50 (rto RrngIS) (orf 'integerp (op eq :)))
    (quickcheck 50 (rto RrngSC) chrp)
    (quickcheck 50 (rstep RrngIS) (memq results (rlist -3..-1 1..3 nil)))
    (quickcheck 50 (rstep RrngSC) (memq results (rlist -3..-1 1..3 nil)))
    (quickcheck 50 (rstep RrngIS*) (memq results (rlist -3..-2 2..3 nil)))
    (quickcheck 50 (rstep* RrngIS) (memq results (rlist -3..3)))
    (quickcheck 50 (rstep* RrngIS*) (eq results (rstep (car args))))
    (quickcheck 50 (rset RrngIS Rint5 Rint5 Rint5) (and (eq (rfrom results) (cadr args))
							(eq (rto results) (caddr args))
							(eq (rstep results) (cadddr args))))
    (test (rrev nil) nil)
    (test (rrev :..:..2) #R(: #R(: -2)))
    (symacrolet ((rrevtest (and (eq (rto results) (from (car args)))
				(eq (from results) (rto (car args))))))
		(quickcheck 50 (rrev RrngIS) rrevtest)
		(quickcheck 50 (rrev RrngSC) rrevtest))
    (test (rrevp nil) nil)
    (symacrolet ((rrevptest (let ((l (take 2 (rlist (car args)))))
			      (if results
				  (> (car l) (or (cadr l) (car l)))
				(<= (car l) (or (cadr l) (car l)))))))
		(quickcheck 50 (rrevp RrngIS) rrevptest)
		(quickcheck 50 (rrevp RrngSC) rrevptest))
    (test (rrev* nil) nil)
    (test (rrev* nil t) nil)
    (quickcheck 50 (rrev* RrngIS) (or (rrevp results)
				      (eq (len (take 2 (rlist (car args)))) 1)
				      (and (eq (from (car args)) :) (greater (rto (car args)) -1))
				      (and (greater (from (car args)) -1) (eq (rto (car args)) :))
				      (and (not (eq (rto results) :))
					   (eq (len (rlist results)) 1))))
    (quickcheck 50 (rrev* RrngIS t) (or (not (rrevp results))
					(eq (len (take 2 (rlist (car args)))) 1)
					(and (eq (from (car args)) :) (less (rto (car args)) 0))))
    (quickcheck 50 (rrev* RrngSC Rbool) (or (call (if (cadr args) 'not 'identity)
						  (rrevp results))
					    (eq (rfrom results) (rto results))
					    (eq (len (rlist results)) 1)))
    (test (rlen :..:) :)
    (test (rlen 0..:) :)
    (test (rlen 0..-5..1) :)
    (test (rlen 0..5..-1) :)
    (test (rlen 0..10..2) 6)
    (test (rlen 0..10..11) 1)
    (test (rlen :..5) 6)
    (test (rlen :..-5) 6)
    (quickcheck 50 (rlen RrngIS) (orf (andf 'numberp (op > 22)) (op eq : @1)))
    (quickcheck 50 (rlen RrngSC) (andf 'numberp (op > 27)))
    (test (rends 4..9 9..3 -3..3 -3..-5) (4 9 -3 -3 9 3 3 -5))
    (test (rends 4..9 9..3 nil -3..3 nil -3..-5) (4 9 -3 -3 9 3 3 -5))
    (test (rends 0..:) (0 :))
    (test (rends :..4) (0 4))
    (test (rends 1..2..3 2..3..4 4..:..5) (1 2 4 2 3 :))
    (symacrolet ((rendstest1 (listp results))
		 (rendstest2 (eq (len results) (* 2 (len args)))))
		(quickcheck 50 (rends . Rl5rngSC)
			    (and rendstest1 rendstest2
				 (all results (orf 'chrp (op eq :)))))
		(quickcheck 50 (rends . Rl5rng10IS)
			    (and rendstest1 rendstest2
				 (all results (orf 'numberp (op eq :))))))
    (test (rmin 4..9 9..3 -3..3 -3..-5) -5)
    (test (rmin 4..9 9..3 nil -3..3 nil -3..-5) -5)
    (test (rmin 0..:) 0)
    (test (rmin :..4) 0)
    (test (rmin 1..2..3 2..3..4 4..:..5) 1)
    (symacrolet ((rmintest (all (rends . args) (op lequal results))))
		(quickcheck 50 (rmin . Rl5rngSC)
			    (and rmintest (or (chrp results) (eq results :))))
		(quickcheck 50 (rmin . Rl5rng10IS)
			    (and rmintest (or (numberp results) (eq results :)))))
    (test (rmax 4..9 9..3 -3..3 -3..-5) 9)
    (test (rmax 4..9 9..3 nil -3..3 nil -3..-5) 9)
    (test (rmax 0..:) :)
    (test (rmax :..4) 4)
    (test (rmax 1..2..3 2..3..4 4..:..5) :)
    (symacrolet ((rmaxtest (all (rends . args) (op gequal results))))
		(quickcheck 50 (rmax . Rl5rngSC)
			    (and rmaxtest (or (chrp results) (eq results :))))
		(quickcheck 50 (rmax . Rl5rng10IS)
			    (and rmaxtest (or (numberp results) (eq results :)))))
    (test (rspan 4..9 9..3 -3..3 5..-5) #R(-5 9))
    (test (rspan 4..9 9..3 nil -3..3 nil 5..-5) #R(-5 9))
    (test (rspan 4..9) #R(4 9))
    (quickcheck 50 (rspan . Rl5rng10IS) rangep)
    (quickcheck 50 (rspan . Rl5rngSC) (andf 'rangep (opip rfrom chrp) (opip rto chrp)))
    (test (rolap 0..5 6..9) ranges:left)
    (test (rolap -5..5 3..9) ranges:olapl)
    (test (rolap -5..10 3..9) ranges:contains)
    (test (rolap 0..5 0..5) ranges:equal)
    (test (rolap 1..1 1..1) ranges:equal)
    (test (rolap 1..1 2..2) ranges:left)
    (test (rolap 2..2 1..1) ranges:right)
    (test (rolap 4..8 3..9) ranges:within)
    (test (rolap 5..10 3..9) ranges:olapr)
    (test (rolap 6..9 0..5) ranges:right)
    (test (rolap 0..3 3..9) ranges:olapl)
    (test (rolap 0..3 -5..0) ranges:olapr)
    (test (rolap :..: :..:) ranges:equal)
    (test (rolap 0..: 0..5) ranges:contains)
    (test (rolap 0..5 0..:) ranges:within)
    (test (rolap :..5 3..:) ranges:olapl)
    (test (rolap 3..: :..5) ranges:olapr)
    (test (rolap -5..-1 :..5) ranges:left)
    (test (rolap :..5 -5..-1) ranges:right)
    (symacrolet ((test (memq @1 '(ranges:equal ranges:left ranges:right ranges:olapl
					       ranges:olapr ranges:contains ranges:within))))
		(quickcheck 50 (rolap RrngIS RrngIS) test)
		(quickcheck 50 (rolap RrngSC RrngSC) test))
    (test (rsort 4..9 9..3 -3..3 -3..-5) (#R(-5 -3) #R(-3 3) #R(3 9) #R(4 9)))
    (test (rsort 4..9..2 9..3..-1 -3..3 -3..-5) (#R(-5 -3) #R(-3 3) #R(3 #R(9 1)) #R(4 #R(9 2))))
    (test (rsort -3..-5 9..3 4..9 -3..3) (#R(-5 -3) #R(-3 3) #R(3 9) #R(4 9)))
    (test (rsort :..-5..1 9..3 4..: :..3) (#R(: #R(-5 1)) #R(: 3) #R(3 9) #R(4 :)))
    (test (rsort -3..-5 nil 9..3 nil 4..9 -3..3) (#R(-5 -3) #R(-3 3) #R(3 9) #R(4 9) nil nil))
    (test (rsort -3..-5) (#R(-5 -3)))
    (test (rsort :..-5..1 9..3 :..-5..-2 4..: :..3 :..-5..2)
	  (#R(-5 #R(: 2)) #R(: #R(-5 2)) #R(: #R(-5 1)) #R(: 3) #R(3 9) #R(4 :)))
    (flet ((rsortests (r a) (and (all r (notf 'rrevp)) (eq (len r) (len a)))))
      (quickcheck 50 (rsort . Rl5rng10) rsortests)
      (quickcheck 50 (rsort . Rl5rng10IS) rsortests)
      (quickcheck 50 (rsort . Rl5rngSC) rsortests))
    (test (runi -3..-5 9..3 4..9 -3..3) (#R(-5 9)))
    (test (runi 4..9 9..3 -3..3 -3..-5) (#R(-5 9)))
    (test (runi -5..5) (#R(-5 5)))
    (test (runi 5..-5) (#R(-5 5)))
    (test (runi -5..-3 3..5) (#R(-5 -3) #R(3 5)))
    (test (runi 3..5 -5..-3) (#R(-5 -3) #R(3 5)))
    (test (runi 4..9 9..3 nil -3..3 nil -3..-5) (#R(-5 9)))
    (test (runi 4..9 9..3 10..10 -3..3 nil -3..-5) (#R(-5 10)))
    (test (runi nil) nil)
    (test (runi 1..1) (#R(1 1)))
    (test (runi 1..1 2..2) (#R(1 2)))
    (test (runi 1..1 nil) (#R(1 1)))
    (test (runi nil 1..1) (#R(1 1)))
    (test (runi nil nil) nil)
    (symacrolet ((runitests (and (all results 'rangep)
				 (<= (len results) (len args)))))
    		(quickcheck 50 (runi . Rl5rng10) runitests)
    		(quickcheck 50 (runi . Rl5rng10IS) runitests)
    		(quickcheck 50 (runi . Rl5rngSC) runitests))
    (test (risec -3..-5 9..3 4..9 -3..3) nil)
    (test (risec 4..9 9..3 -3..3 -3..-5) nil)
    (test (risec -5..5) #R(-5 5))
    (test (risec 5..-5) #R(-5 5))
    (test (risec -5..5 3..10) #R(3 5))
    (test (risec 3..10 -5..5 4..5) #R(4 5))
    (test (risec 3..10 -5..5 nil 4..5) nil)
    (test (risec 1..1) #R(1 1))
    (test (risec 3..10 -5..5 4..4 4..5) #R(4 4))
    (test (risec nil) nil)
    (test (risec nil nil) nil)
    (test (risec nil 1..1) nil)
    (symacrolet ((risectests (or (null results)
    				 (and (rangep results)
    				      (not (rstep results))
    				      (all (rends . args)
    					   (orf (op eq (rfrom results))
    						(op eq (rto results))
    						(notf (op in-range results))))))))
    		(quickcheck 50 (risec . Rl5rng10) risectests)
    		(quickcheck 50 (risec . Rl5rngSC) risectests)
    		(quickcheck 50 (risec . Rl5rng10IS) risectests))
    (test (rdiff -7..0 -3..-5 9..3 4..9 -3..3) ((#R(-7 -6)) #R(1 9)))
    (test (rdiff (list -3..-5 9..3 4..9 -3..3) -7..0) ((#R(1 9)) #R(-7 -6)))
    (test (rdiff -5..-3 3..5) ((#R(-5 -3)) #R(3 5)))
    (test (rdiff 5..3 -3..-5) ((#R(3 5)) #R(-5 -3)))
    (test (rdiff 5..3 nil) ((#R(3 5))))
    (test (rdiff nil 3..5) (nil #R(3 5)))
    (test (rdiff nil -3..-5 4..9 -3..3) (nil #R(-5 9)))
    (test (rdiff (list -3..-5 4..9 -3..3) nil) ((#R(-5 9))))
    (test (rdiff nil nil) (nil))
    (test (rdiff 1..4 1..4) (nil))
    (test (rdiff 1..1 3..3) ((#R(1 1)) #R(3 3)))
    (test (rdiff 1..1 1..1) (nil))
    (test (rdiff 1..1 nil) ((#R(1 1))))
    (test (rdiff 1..1 nil 2..2) ((#R(1 1)) #R(2 2)))
    (test (rdiff 1..1 -3..-5 nil 4..9 -3..3) (nil #R(-5 0) #R(2 9)))
    (test (rdiff 1..1 -3..-5 2..2 4..9 -3..3) (nil #R(-5 0) #R(2 9)))
    (test (rdiff (list -3..-5 2..2 4..9 -3..3) 1..1) ((#R(-5 0) #R(2 9))))
    (test (rdiff nil nil) (nil))
    (test (rdiff 1..4 2..4) ((#R(1 1))))
    (test (rdiff 1..1 0..5) (nil #R(0 0) #R(2 5)))
    (test (rdiff 1..1 0..5 7..7) (nil #R(0 0) #R(2 5) #R(7 7)))
    (test (rdiff 0..5 1..1) ((#R(0 0) #R(2 5))))
    (test (rsplit 0..10) (#R(0 10)))
    (test (rsplit 0..10 0) (#R(0 10)))
    (test (rsplit 0..10 10) (#R(0 10)))
    (test (rsplit 0..10 -5) (#R(0 10)))
    (test (rsplit 0..10 15) (#R(0 10)))
    (test (rsplit 0..10 5) (#R(0 5) #R(5 10)))
    (test (rsplit 0..10 '(3 5)) (#R(0 3) #R(3 5) #R(5 10)))
    (test (rsplit 0..10 '(5 3)) (#R(0 3) #R(3 5) #R(5 10)))
    (test (rsplit 0..10 '(3 3 5)) (#R(0 3) #R(3 5) #R(5 10)))
    (test (rsplit 0..10 '(10 15 20)) (#R(0 10)))
    (test (rsplit 0..10 '(0 -5 -10)) (#R(0 10)))
    (test (rsplit -10..10) (#R(-10 0) #R(0 10)))
    (test (rsplit 10..-10) (#R(10 0) #R(0 -10)))
    (test (rsplit -10..10 '(5 0 -5)) (#R(-10 -5) #R(-5 0) #R(0 5) #R(5 10)))
    (test (rsplit -10..10 '(-5 0 5)) (#R(-10 -5) #R(-5 0) #R(0 5) #R(5 10)))
    (test (rsplit 0..10 5 t) (#R(0 4) #R(5 10)))
    (test (rsplit 0..10 '(3 5) t) (#R(0 2) #R(3 4) #R(5 10)))
    (test (rsplit 10..0 5 t) (#R(10 6) #R(5 0)))
    (test (rsplit 10..-10 0 t) (#R(10 1) #R(0 -10)))
    (test (rsplit 5..5) (#R(5 5)))
    (test (rsplit -5..-5) (#R(-5 -5)))
    (test (rsplit 0..0) (#R(0 0)))

    (test (listr nil) nil)
    (test (listr '(nil)) nil)
    (test (listr '(nil nil)) nil)
    (test (listr (rlist 0..10)) (#R(0 10)))
    (test (listr (list 0..10)) (#R(0 10)))
    (test (listr (rlist 10..0)) (#R(10 0)))
    (test (listr (list 10..0)) (#R(10 0)))
    (test (listr (rlist -5..0)) (#R(-5 0)))
    (test (listr (list -5..0)) (#R(-5 0)))
    (test (listr (rlist 0..-5)) (#R(0 -5)))
    (test (listr (list 0..-5)) (#R(0 -5)))
    (test (listr (nconc (rlist 0..5) (rlist 0..-5))) (#R(0 5) #R(0 -5)))
    (test (listr (list 0..5 0..-5)) (#R(0 5) #R(0 -5)))
    (test (listr (list 0..-5 0..5)) (#R(0 -5) #R(0 5)))
    (test (listr (nconc (rlist -5..5) (rlist 10..3))) (#R(-5 5) #R(10 3)))
    (test (listr (list -5..5 10..3)) (#R(-5 5) #R(10 3)))
    (test (listr '(0)) (#R(0 0)))
    (test (listr '(0 4 2 9 5)) (#R(0 0) #R(4 4) #R(2 2) #R(9 9) #R(5 5)))
    (test (listr '(0 1 2 4 3 2 9 9 9 8 7 0 -1 -2)) (#R(0 2) #R(4 2) #R(9 9) #R(9 9) #R(9 7) #R(0 -2)))
    (test (listr (list 4 5..5)) (#R(4 5)))
    (test (listr (list 5..5 4)) (#R(5 4)))
    (test (listr (list 9..6 5..5)) (#R(9 5)))
    (test (listr (list -9..-6 -5..-5)) (#R(-9 -5)))
    (test (listr (list 2..4 5..5)) (#R(2 5)))
    (test (listr (list -2..-4 -5..-5)) (#R(-2 -5)))

    (test (listr* nil) nil)
    (test (listr* '(nil)) nil)
    (test (listr* '(nil nil)) nil)
    (test (listr* (rlist 0..10)) (#R(0 11)))
    (test (listr* (list 0..10)) (#R(0 10)))
    (test (listr* (rlist 5..0)) (#R(5 6) #R(4 5) #R(3 4) #R(2 3) #R(1 2) #R(0 1)))
    (test (listr* (list 5..0)) (#R(5 6) #R(4 5) #R(3 4) #R(2 3) #R(1 2)))
    (test (listr* (rlist -5..0)) (#R(-5 0) #R(0 1)))
    (test (listr* (list -5..0)) (#R(-5 0)))
    (test (listr* (rlist 0..-5)) (#R(0 1) #R(-1 0) #R(-2 -1) #R(-3 -2) #R(-4 -3) #R(-5 -4)))
    (test (listr* (list 0..-5)) (#R(0 1) #R(-1 0) #R(-2 -1) #R(-3 -2) #R(-4 -3)))
    (test (listr* (nconc (rlist 0..2) (rlist 0..-2))) (#R(0 3) #R(0 1) #R(-1 0) #R(-2 -1)))
    (test (listr* (list 0..2 0..-2)) (#R(0 2) #R(0 1) #R(-1 0)))
    (test (listr* (list 0..-2 0..2)) (#R(0 1) #R(-1 0) #R(0 2)))
    (test (listr* (nconc (rlist -5..5) (rlist 5..3))) (#R(-5 0) #R(0 6) #R(5 6) #R(4 5) #R(3 4)))
    (test (listr* (list -5..5 5..3)) (#R(-5 0) #R(0 5) #R(5 6) #R(4 5)))
    (test (listr* '(0)) (#R(0 1)))
    (test (listr* '(0 4 2 9 5)) (#R(0 1) #R(4 5) #R(2 3) #R(9 10) #R(5 6)))
    (test (listr* (list -1..-1 0..0 1..1)) ())
    (test (listr* (list 4 5..5)) (#R(4 5)))
    (test (listr* (list 5..5 4)) (#R(4 5)))
    (test (listr* (list -9..-6 -5..-5)) (#R(-9 -6)))
    (test (listr* (list 2..4 5..5)) (#R(2 4)))
    (test (listr* (list -2..-4 -5..-5)) (#R(-2 -1) #R(-3 -2)))


    (test (slice-list (range 0 10) (range 0 10 2)) (0 2 4 6 8 10))
    (test (slice-list (range 0 10) (range 1 10 2)) (1 3 5 7 9))
    (test (slice-list (range 0 10) 0..5) (0 1 2 3 4 5))
    (test (slice-list (range 0 10) 5..0) (5 4 3 2 1 0))
    (test (slice-list (range 0 10) -2..0) (9 10 0))
    (test (slice-list (range 0 10) 0..-2) (0 10 9))
    (test (slice-list (range 0 10) -3..3) (8 9 10 0 1 2 3))
    (test (slice-list (range 0 10) 3..-3) (3 2 1 0 10 9 8))
    (test (slice-list (range 0 10) 3) (3))
    (test (slice-list (range 0 10) -3) (8))
    (test (slice-list (range 0 10) -1) (10))
    (test (slice-list (range 0 10) '(-1 1 0 -2 2 0)) (10 1 0 9 2 0))
    (test (slice-list (range 0 10) (list 0..3 4..8)) (0 1 2 3 4 5 6 7 8))
    (test (slice-list (range 0 10) (list -3..3 3..-3)) (8 9 10 0 1 2 3 3 2 1 0 10 9 8))
    (test (slice-list (range 0 10) (list 3..-3 -3..3)) (3 2 1 0 10 9 8 8 9 10 0 1 2 3))
    (test (slice-list (range 0 10) (list 0 1 2 (list 3 4..10 5) 6 7 8)) (0 1 2 3 4 5 6 7 8 9 10 5 6 7 8))
    (test (slice-list (range 0 10) 'evenp) (0 2 4 6 8 10))
    (test (slice-list (range 0 10) (symbol-function 'evenp)) (0 2 4 6 8 10))
    (test (slice-list (range 0 10) 'oddp) (1 3 5 7 9))
    (test (slice-list (range 0 10) (symbol-function 'oddp)) (1 3 5 7 9))
    (test (slice-list (range 0 10) (op > @1 5)) (6 7 8 9 10)))

  (unuse-package "ranges")
  [loadpkg "csv"]

  (test (read-csv-stream (make-strlist-input-stream '("c1,c2,c3" "a,b,c" "1,2,3"))).data
	(("c1" "c2" "c3") ("a" "b" "c") ("1" "2" "3")))
  (test (read-csv-stream (make-strlist-input-stream '("c1,c2,c3" "a,b,c" "1,2,3"))).ncols
	3)
  (test (read-csv-stream (make-strlist-input-stream '("c1,c2,c3" "a,b,c" "1,2,3"))).(nrows)
	3)
  (test (read-csv-stream (make-strlist-input-stream '("c1,c2,c3" "a,b,c" "1,2,3"))).headers
	nil)
  (test (read-csv-stream (make-strlist-input-stream '("c1,c2,c3" "a,b,c" "1,2,3")) :header t).(nrows)
	2)
  (test (read-csv-stream (make-strlist-input-stream '("c1,c2,c3" "a,b,c" "1,2,3")) :header t).headers
	("c1" "c2" "c3"))
  (test (read-csv-stream (make-strlist-input-stream '("c1,c2,c3" "a,b,c" "1,2,3")) :header '("h1" "h2" "h3")).ncols
	3)
  (test (read-csv-stream (make-strlist-input-stream '("c1,c2,c3" "a,b,c" "1,2,3")) :header '("h1" "h2" "h3")).(nrows)
	3)
  (test (read-csv-stream (make-strlist-input-stream '("c1,c2,c3" "a,b,c" "1,2,3")) :header '("h1" "h2" "h3")).headers
	("h1" "h2" "h3"))
  (test (read-csv-stream (make-strlist-input-stream '("c1,c2,c3" "a,\"b,e\",c" "1,2,\"34\""))).data
	(("c1" "c2" "c3") ("a" "\"b,e\"" "c") ("1" "2" "\"34\"")))
  (test (read-csv-stream (make-strlist-input-stream '("c1,c2,c3" "a,\"b,e\",c" "1,2,\"34\"")) :unquote t).data
	(("c1" "c2" "c3") ("a" "b,e" "c") ("1" "2" "34")))
  (test (read-csv-stream (make-strlist-input-stream '("c1  ,c2  ,c3  " "a,  b,c" "1,2,34  ")) :trim t).data
	(("c1" "c2" "c3") ("a" "b" "c") ("1" "2" "34")))
  (test (read-csv-stream (make-strlist-input-stream '("c1,c2,c3" "a,,c" "1,2,")) :emptystr "FOO").data
	(("c1" "c2" "c3") ("a" "FOO" "c") ("1" "2" "FOO")))
  (test (read-csv-stream (make-strlist-input-stream '("  c1,c2  , c3" "a,  \"b,e\"," "1,,\"34\"  "))
			 :trim t :unquote t :emptystr "FOO").data
			 (("c1" "c2" "c3") ("a" "b,e" "FOO") ("1" "FOO" "34")))

  (let* ((csv1 (new (csvdata 2 '("c1" "c2") '((1 2) (2 3) (3 4))))))
    (test csv1.ncols 2)
    (test csv1.(nrows) 3)
    (test csv1.data ((1 2) (2 3) (3 4)))
    (test [csv1 0..2] ((1 2) (2 3) (3 4)))
    (test [csv1 0..2 0..1] ((1 2) (2 3) (3 4)))
    (test [csv1 0..2 'c1] ((1) (2) (3)))
    (test [csv1 0..2 "c1"] ((1) (2) (3)))
    (test [csv1 0..2 'c2] ((2) (3) (4)))
    (test [csv1 0..2 "c2"] ((2) (3) (4)))
    (test [csv1 0..2 '(c1 c2)] ((1 2) (2 3) (3 4)))
    (test [csv1 0..2 '("c1" "c2")] ((1 2) (2 3) (3 4)))
    (test [csv1 0..2 '("c1" 'c2)] ((1 2) (2 3) (3 4)))
    (test [csv1 0..2 '("c1" 1)] ((1 2) (2 3) (3 4)))
    )
  (unuse-package "csv")
  ;; reload any packages that were already loaded before starting
  (use-package loadedpkgs))
